<?php
/**
 * Crypt
 *
 * @author Ashley Kitson
 * @copyright Ashley Kitson, 2015, UK
 * @license GPL V3+ See LICENSE.md
 */
namespace Chippyash\Test\Crypt;

use Chippyash\Crypt\Crypt;
use Chippyash\Crypt\CryptException;
use Chippyash\Type\String\StringType;
use Chippyash\Type\BoolType;

/**
 * Generated by PHPUnit_SkeletonGenerator 1.2.1 on 2013-06-18 at 13:08:07.
 *
 * @requires mcrypt
 */
class CryptTest extends \PHPUnit_Framework_TestCase {

    /**
     * secret key to use.
     */
    const SEED = '449a5b69-34cb-4745-ad92-b32f90f0c5a6';
    
    /**
     * @var Crypt
     */
    protected $sut;

    /**
     * Mock
     * @var MethodInterface
     */
    protected $method;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        $this->method = $this->getMock('Chippyash\Crypt\Method\MethodInterface');
        $this->sut = new Crypt(new StringType(self::SEED), $this->method);
    }

    /**
     * NB we have to use reflection to get at the value of the private property for this test
     * By default the useMac value == true
     *
     */
    public function testYouCanSetTheUseOfTheMacAddress() {
        $this->sut->setUseMacAddress(new BoolType(false));
        $reflClass = new \ReflectionObject($this->sut);
        $property = $reflClass->getProperty('useMac');
        $property->setAccessible(true);
        $this->assertFalse($property->getValue($this->sut));
    }

    public function testYouCanEncryptAndDecrypt() {
        $this->method->expects($this->once())
            ->method('encrypt')
            ->will($this->returnValue('bar'));
        $this->method->expects($this->once())
            ->method('decrypt')
            ->will($this->returnValue('foofoofoofoo'));
        $crypt = $this->sut->mcEncrypt('foofoofoofoo');
        $decrypt = $this->sut->mcDecrypt($crypt);
        $this->assertEquals('foofoofoofoo', $decrypt);
    }

    public function testDefaultEncryptionWillBase64EncodeTheResult()
    {
        $this->method->expects($this->once())
            ->method('encrypt')
            ->will($this->returnValue('bar'));
        $crypt = $this->sut->mcEncrypt('foo');
        $this->assertEquals(base64_encode('bar'), $crypt);
    }

    public function testDefaultEncryptionExpectsABase64EncodedInputValue()
    {
        $enc = base64_encode('bar');
        $this->method->expects($this->once())
            ->method('decrypt')
            ->will($this->returnValue('foo'));
        $decrypt = $this->sut->mcDecrypt($enc);
        $this->assertEquals('foo', $decrypt);
    }

    public function testYouCanSwitchOffBase64EncodingForEncryption()
    {
        $this->method->expects($this->once())
            ->method('encrypt')
            ->will($this->returnValue('bar'));
        $crypt = $this->sut->mcEncrypt('foo', new BoolType(false));
        $this->assertEquals('bar', $crypt);
    }

    public function testYouCanSwitchOffBase64EncodingForDecryption()
    {
        $this->method->expects($this->once())
            ->method('decrypt')
            ->will($this->returnValue('bar'));
        $crypt = $this->sut->mcDecrypt('foo', new BoolType(false));
        $this->assertEquals('bar', $crypt);
    }

    public function testDecryptingAnEmptyValueWillReturnTheSameValue()
    {
        $crypt = $this->sut->mcDecrypt('');
        $this->assertEmpty($crypt);
    }
}
